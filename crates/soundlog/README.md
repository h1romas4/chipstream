# soundlog

Builder and parser for retro sound-chip register-write logs (VGM)

`soundlog` is a small Rust crate for constructing and parsing register-write
logs for retro sound chips. It focuses on the VGM (Video Game Music)
file format and provides type-safe APIs for building VGM documents and
representing chip-specific register writes.

Features

- Builder API to construct `VgmDocument` programmatically.
- Parser to read VGM bytes into a structured `VgmDocument`.
- Type-safe chip specifications and command types to reduce invalid writes.
- Stream processing: `VgmStream` — a low-memory, iterator-style processor that accepts chunked VGM binary input or a parsed `VgmDocument` and yields parsed/expanded `VgmCommand` values incrementally.

## Quick start

## VgmBuilder

```rust
use soundlog::{VgmBuilder, VgmDocument};
use soundlog::chip::{Chip, Ym2612Spec};
use soundlog::vgm::command::{WaitSamples, Instance};
use soundlog::meta::Gd3;

let mut builder = VgmBuilder::new();

// Register the chip master clock in the header (Hz)
builder.register_chip(Chip::Ym2612, Instance::Primary, 7_670_454);

// Append a chip write using a chip-specific spec
builder.add_chip_write(
    Instance::Primary,
    Ym2612Spec { port: 0, register: 0x22, value: 0x91 },
);

builder.add_vgm_command(WaitSamples(44100));

builder.set_gd3(Gd3 {
    track_name_en: Some("Example Track".to_string()),
    game_name_en: Some("soundlog examples".to_string()),
    ..Default::default()
});

let document: VgmDocument = builder.finalize();
let bytes: Vec<u8> = document.into();
```

## VgmDocument as Parser

```rust
use soundlog::{VgmBuilder, VgmDocument};
use soundlog::vgm::command::{WaitSamples, VgmCommand};

let mut b = VgmBuilder::new();
b.add_vgm_command(WaitSamples(100));
b.add_vgm_command(WaitSamples(200));
let doc = b.finalize();
let bytes: Vec<u8> = (&doc).into();

let document: VgmDocument = (bytes.as_slice())
    .try_into()
    .expect("failed to parse serialized VGM");

let total_wait: u32 = document
    .iter()
    .map(|cmd| match cmd {
        VgmCommand::WaitSamples(s) => s.0 as u32,
        _ => 0,
    })
    .sum();

assert_eq!(total_wait, 300);
```

## VgmStream

`soundlog` also provides `VgmStream`, a low-memory, iterator-style processor for VGM documents and chunked VGM binary input. `VgmStream` accepts either raw VGM bytes (pushed incrementally) or a parsed `VgmDocument` via `VgmStream::from_document`. As it consumes input it yields `VgmCommand` values (wrapped in the stream's result type) — this includes both commands parsed from the document and chip writes that are generated by DAC stream commands (DataBlock / SetupStreamControl / StartStream / StartStreamFastCall / StopStream).

Important characteristics:

- Low-memory: designed to process large VGM data without loading everything into memory at once.
- Incremental: supports feeding chunked binary input via `push_data`.
- Stream-aware: during `Wait` commands, the scheduler finds upcoming DAC-stream-generated writes and splits waits so stream writes are interleaved with document commands at the correct per-sample times.
- From-document convenience: `VgmStream::from_document` constructs a stream iterator from a parsed `VgmDocument`, expanding stream-generated writes into the emitted command sequence.

Example: using `VgmStream::from_document`

The following example demonstrates building a minimal `VgmDocument` (including a chip write) and iterating the expanded command stream. The stream will emit parsed commands as well as any writes generated by active DAC streams; waits may be split to allow interleaving of generated writes at precise sample offsets.

```rust
use soundlog::{VgmBuilder, VgmStream, VgmDocument};
use soundlog::vgm::command::{VgmCommand, WaitSamples, SetupStreamControl, StartStream, Instance};
use soundlog::chip::Ym2612Spec;

// Build a minimal document that contains a data block and stream control
// commands. (Builder helpers for data blocks / stream setup exist on the
// `VgmBuilder` type; see the vgm module docs for details.)
let mut b = VgmBuilder::new();
// Example: append a YM2612 chip register write using the chip-specific spec
b.add_chip_write(
    Instance::Primary,
    Ym2612Spec {
        port: 0,
        register: 0x22,
        value: 0x91,
    },
);
// (pseudo-code) append data block, configure stream and start it
// b.add_data_block(...);
// b.add_vgm_command(SetupStreamControl { /* ... */ });
// b.add_vgm_command(StartStream { /* ... */ });
b.add_vgm_command(WaitSamples(8));

let doc: VgmDocument = b.finalize();

// Create a stream from the parsed document. The iterator will yield
// parsed commands as well as any stream-generated writes expanded into
// the timeline.
let mut stream = VgmStream::from_document(doc);
while let Some(result) = stream.next() {
    match result {
        Ok(soundlog::vgm::stream::StreamResult::Command(cmd)) => match cmd {
            VgmCommand::WaitSamples(s) => {
                // Waits may have been split to accommodate stream-generated writes.
                println!("wait {} samples", s.0);
            }
            VgmCommand::Ym2612Write(inst, spec) => {
                // Handle YM2612 writes here. For example, forward to a device API.
                println!("YM2612 write: {:?} {:?}", inst, spec);
            }
            other => {
                // Write to the target chips here (e.g. SN76489).
                // Implement actual playback / device I/O in this branch.
                println!("cmd: {:?}", other)
            },
        },
        Ok(soundlog::vgm::stream::StreamResult::NeedsMoreData) => break,
        Ok(soundlog::vgm::stream::StreamResult::EndOfStream) => break,
        Err(e) => eprintln!("stream error: {:?}", e),
    }
}
```

## Running tests

```bash
cargo test -p soundlog
```

## License

MIT License
